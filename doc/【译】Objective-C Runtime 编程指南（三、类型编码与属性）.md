[Objective-C runtime Programming Guide 官档传送门](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCruntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048-CH1-SW1)

本文翻译自2009-10-19版的官档。
您可以在官档结尾的Document Revision History中查阅版本。
注：【】包含的部分引自原文。

## 类型编码【Type Encodings】
为了协助runtime系统（后文简称runtime），编译器会将方法的参数与返回值编码为一个C字符串，并将其和方法的selector绑定。编码系统在其他场景也会用到，因此编译器公开了@encode() 这个编译器指令。给定一个类型，@encode()可以返回编码后的C字符串，变量可以是int这种基本类型，也可以是结构体、union，也可以是类名。事实上，任意可以作为C函数sizeof()的参数的，都可以作为@encode()的参数。
```
char *buf1 = @encode(int **);
char *buf2 = @encode(struct key);
char *buf3 = @encode(Rectangle);
```
下表中列举了类型编码。当你想序列化或分发对象时也需要对对象编码，注意到两种编码有部分码是共有的。当你编写coder（译注：从下文看，NSCoder）时，你不能使用下表的码，除非它不支持@encode()。（译注：翻译可能有误）【there are codes that you may want to use when writing a coder that aren’t generated by @encode()】。更多信息请参考Foundation的NSCoder类。

表 6- 1 OC类型编码
![](~/OCTypeEncoding.png)

> 重要：OC不支持long double类型， @encode(long double) 返回d，和double一样。

数组的编码是方括号中包含元素个数+元素编码，例如数组包含12个float指针，如下：
```
[12^f]
```
结构体是在大括号(union也类似，只是在小括号中)中优先列出结构体标签【structure tag】，然后是一个等号，之后顺序排列各变量的编码，例如下面的结构体：
```
typedef struct example {
    id   anObject;
    char *aString;
    int  anInt;
} Example;
```
将会编码成这样：
```
{example=@*i}
```

结构体指针也要完整地列出结构体信息，如指向Example的指针如下：
```
^{example=@*i}
```
但更多层的指针，则不必再列出结构体信息，例如：
```
^^{example}
```

对象和结构体也类似，只不过最前面是类名，例如NSObject：
```
{NSObject=#}
```
NSObject中只有一个Class类型的isa变量。

除此之外，runtime还有一些专用的编码，@encode()不会返回这些编码，一般是用来修饰协议中声明的方法，如表6-2所示：

表 6-2
![](~/OCMethodTypeEncoding.png)


## 属性【Declared Properties】
编译器遇到属性声明时，它会生成相关的描述元信息，并将其和属性所属的类或协议等绑定。你可以使用相关的函数来通过名字访问属性的元信息。你可以获取到属性类型的@encode C字符串，以及一组属性的特性【attribute】的C字符串。每个类或协议中都有自己的属性信息列表。

### 属性类型和函数
Property结构体定义了一个指向属性objc_property的不透明句柄。
```
typedef struct objc_property *Property;
```
你可以使用class_copyPropertyList以及protocol_copyPropertyList函数来获取类或协议关联的属性列表：
```
objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)
objc_property_t *protocol_copyPropertyList(Protocol *proto, unsigned int *outCount)
```
例如，下面的类定义：
```
@interface Lender : NSObject {
    float alone;
}
@property float alone;
@end
```

你可以获取它的属性列表：
```
id LenderClass = objc_getClass("Lender");
unsigned int outCount;
objc_property_t *properties = class_copyPropertyList(LenderClass, &outCount);
```

你也可以使用property_getName函数，获取属性的名字：
```
const char *property_getName(objc_property_t property)
```

你可以使用class_getProperty或protocol_getProperty来根据名字获取特定的属性：
```
objc_property_t class_getProperty(Class cls, const char *name)
objc_property_t protocol_getProperty(Protocol *proto, const char *name, BOOL isRequiredProperty, BOOL isInstanceProperty)
```

你可以使用property_getAttributes方法，获取属性的名字和@encode C字符串，类型的编码可参考Type Encodings一章，而属性的编码可参考后文的Property Type String 和 Property Attribute Description Examples 章节。

```
const char *property_getAttributes(objc_property_t property)
```

综上，你可以像下面这样打印一个类的属性列表：
```
id LenderClass = objc_getClass("Lender");
unsigned int outCount, i;
objc_property_t *properties = class_copyPropertyList(LenderClass, &outCount);
for (i = 0; i < outCount; i++) {
    objc_property_t property = properties[i];
    fprintf(stdout, "%s %s\n", property_getName(property), property_getAttributes(property));
}
```

### 属性类型字符串
你可以使用property_getAttributes获取属性的名字、@encode 类型字符串、以及属性的特性信息。
字符串以T+属性的@encode类型串+逗号开头，以V+属性名结束，两者之间包含属性的特性编码，用逗号分隔，特性编码如表7-1所示：
![](~/PropertyTypeEncoding.png)
详细示例见后文。

### 属性特性描述示例【Property Attribute Description Examples】
我们先定义几个示例用到的结构
```
enum FooManChu { FOO, MAN, CHU };
struct YorkshireTeaStruct { int pot; char lady; };
typedef struct YorkshireTeaStruct YorkshireTeaStructType;
union MoneyUnion { float alone; double down; };
```

下表展示了property_getAttributes返回的属性描述。

表7-2 
![](~/PropertyTypeEncodingSample.png)
